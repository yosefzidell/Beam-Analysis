import dash
from dash import dcc, html, Input, Output, State, dash_table, ALL, MATCH
import plotly.graph_objs as go
import pandas as pd
from dash import dcc, callback_context
from dash import html
import dash_bootstrap_components as dbc
import numpy as np
from itertools import chain
import time

# Initialize the Dash app
external_stylesheets = ['/assets/animations.css']

app = dash.Dash(__name__, external_stylesheets=external_stylesheets)

# Sample data for the table
sample_data = {
    " ": ["Shear (Kip)", "Moment (K-ft)", "Deflection (ft)"],
    "Critical": [0, 0, 0],
    "Design": ['-', '-', '-'],
    "Safety Percent": ['-', '-', '-']
}
df = pd.DataFrame(sample_data)

# Button style
button_style = {
    'backgroundColor': '#5072a7',
    'color': '#000000',
    'border': 'none',
    'padding': '10px 20px',
    'borderRadius': '10px',
    'cursor': 'pointer',
    'fontSize': '16px',
    'marginTop': '40px',
    'marginBottom': '20px',
    'margin-left': '5px',
    'alignSelf': 'center',

}

# Delete Button style
delete_button_style = {
    'backgroundColor': '#2B3A67',
    'color': '#000000',
    'border': 'none',
    'cursor': 'pointer',
    'fontSize': '16px',
    'alignSelf': 'center',
}

dropdown_style = {
    'backgroundColor': '#8FA6F0',
    'color': 'black',
    'width': '200px',
    'border': 'none',
    'padding': '0px',
    'borderRadius': '5px',
    'cursor': 'pointer',
    'fontSize': '16px',
    'marginTop': '10px',
    'marginBottom': '20px',
    'display': 'flex',
    'justifyContent': 'right',
    'alignItems': 'center',
    'textAlign': 'center',
    'height': '30px'
}

label_style = {
    'margin-left': '22px',
    'fontWeight': 'bold',
    'color': '#A6B1E1',
    'text-align': 'center'
}

input_style = {
    'backgroundColor': '#8FA6F0',
    'color': '#000000',
    'border': 'none',
    'padding': '0px',
    'borderRadius': '2px',
    'margin-bottom': '5px',
    'cursor': 'pointer',
    'fontSize': '14px',
    'textAlign': 'center',
    'width': '20px'

}
container_style = {
    'backgroundColor': '#A6B1E1',
    'height': '50px',
    'width': '100%',
    'marginTop': '10px',
    'borderRadius': '5px',
}

# App Layout
app.layout = html.Div(
    style={
        'backgroundColor': '#E0E0E0',
        'fontFamily': 'Arial, sans-serif',
        'display': 'flex',
        'flexDirection': 'row',
        'height': '100vh',
        'overflow': 'hidden'
    },
    children=[
        # Left Column (35%)
        html.Div(
            style={
                'width': '35%',
                'padding': '20px',
                'backgroundColor': '#2B3A67',
                'color': '#FFFFFF',
                'overflowY': 'auto',
                'display': 'flex',
                'flexDirection': 'column',
                'alignItems': 'center',  # Centers items horizontally
                'justifyContent': 'flex-start'
            },
            children=[
                # Header Section
                html.Div(
                    children=[
                        html.H1(
                            'Welcome to Beam Analysis',
                            className='animated-header-1',
                            style={
                                'fontSize': '28px',
                                'fontWeight': 'bold',
                                'textAlign': 'center',
                                'marginTop': '30px',
                                'marginBottom': '30px',
                                'color': '#A6B1E1'
                            }
                        ),
                        html.P(
                            'This app allows you to clearly and efficiently build a beam with applied loads and determine the optimal beam design. Use the controls below to get started.',
                            className='animated-header-1',
                            style={
                                'fontSize': '16px',
                                'textAlign': 'center',
                                'marginBottom': '40px',
                                'color': '#A6B1E1'
                            }
                        )
                    ]
                ),
                # horizontal seperator line
                html.Hr(
                    style={
                        'borderColor': '#A6B1E1',
                        'borderWidth': '1px',
                        'width': '100%',
                        'margin': '20px 0'
                    }
                ),
                html.Div(
                    className='animated-header-1',
                    style={"display": "flex", "flexDirection": "column", "alignItems": "center",
                           "justifyContent": "top"},
                    children=[
                        html.H2('Beam Layout',
                                style=
                                {'textDecoration': 'underline',
                                 'color': '#A6B1E1',
                                 'marginBottom': '15px',
                                 'textAlign': 'center'
                                 }
                                ),
                        html.P(
                            'Choose the number of supports, span lengths, and end support types below. See the real-time effect of your changes on beam diagram on the right side of the screen.',
                            style={
                                'fontSize': '16px',
                                'textAlign': 'center',
                                'marginBottom': '60px',
                                'color': '#A6B1E1'
                            }
                        ),
                        html.Label('Number of Supports',
                                   style={'margin-left': '22px', 'fontWeight': 'bold', 'color': '#A6B1E1',
                                          'text-align': 'center'}),
                        dcc.Dropdown(
                            id='support-dropdown',
                            options=[{'label': str(i), 'value': i} for i in range(2, 11)],
                            value=2,  # Default value
                            clearable=False,
                            style=dropdown_style
                        ),
                        # container for spacing input boxes
                        html.Div(id='input-boxes', style={'margin-bottom': '30px', 'textAlign': 'center', }),

                        # left support dropdown
                        html.Label("Left End Support Type:",
                                   style={'margin-left': '12px', 'fontWeight': 'bold', 'color': '#A6B1E1',
                                          'text-align': 'center'}),
                        dcc.Dropdown(
                            id='left-dropdown',
                            options=['Simple', 'Moment', 'None (Overhang)'],
                            value='Simple',
                            style=dropdown_style
                        ),

                        # right support dropdown
                        html.Label("Right End Support Type:",
                                   style={'margin-left': '8px', 'fontWeight': 'bold', 'color': '#A6B1E1',
                                          'text-align': 'center'}),
                        dcc.Dropdown(
                            id='right-dropdown',
                            options=['Simple', 'Moment', 'None (Overhang)'],
                            value='Simple',
                            style=dropdown_style
                        ),
                        html.Label('Select Diagram Type:',
                                   style={'margin-left': '22px', 'fontWeight': 'bold', 'color': '#A6B1E1',
                                          'text-align': 'center'}),

                        # diagram type dropdown
                        dcc.Dropdown(
                            id='force-dropdown',
                            options=['Shear Diagram', 'Moment Diagram'],
                            value='Shear Diagram',  # Default selection
                            clearable=False,
                            style=dropdown_style
                        )
                    ]
                ),

                # horizontal seperator line
                html.Hr(
                    style={
                        'borderColor': '#A6B1E1',
                        'borderWidth': '1px',
                        'width': '100%',
                        'margin': '20px 0'
                    }
                ),  # Separator Line

                # Loads Section
                html.Div(
                    className='animated-header-1',
                    children=[
                        html.H2('Loads',
                                style={'textDecoration': 'underline', 'color': '#A6B1E1', 'marginBottom': '15px',
                                       'text-align': 'center'
                                       }),
                        html.P(
                            'Add the factored loads on your beam below. See the real-time effect of your changes on beam diagram on the right side of the screen.',
                            style={
                                'fontSize': '16px',
                                'textAlign': 'center',
                                'marginBottom': '10px',
                                'color': '#A6B1E1'
                            }
                        ),
                        html.Div(
                            id="modal",
                            className='animated-header-1',
                            children=[
                                html.Div(
                                    id="modal-content",
                                    children=[
                                        html.Button("X", id="close-modal", n_clicks=0,
                                                    style={'position': 'absolute',
                                                           'top': '5px',
                                                           'right': '5px',
                                                           'fontSize': '10px'}),
                                        html.P(
                                            "For uniform loads applied to the beam, the end of the load must be greater than the beginning of the load.",
                                            style={'color': '#000000'}),
                                    ],
                                    style={
                                        'backgroundColor': '#f0f8ff',
                                        'padding': '0px',
                                        'borderRadius': '10px',
                                        'width': '50%',
                                        'position': 'relative',
                                        'top': '0',
                                        'right': '75%',
                                        'transform': 'translate(-50%, -50%)',
                                        'boxShadow': '0 4px 8px rgba(0, 0, 0, 0.1)',
                                        'fontSize': '10px',
                                    }
                                )
                            ],
                            style={
                                'position': 'fixed',
                                'backgroundColor': '#A6B1E1',
                                'top': 0,
                                'left': 0,
                                'width': '25%',
                                'height': '100%',
                                'display': 'none',  # Hidden by default
                            }
                        ),
                        # create two columns for the point loads and uniform loads
                        html.Div(
                            style={
                                'display': 'flex',
                                'width': '100%',
                                'alignItems': 'top',  # both column data starts from top of this container
                                'justifyContent': 'center',
                                'marginTop': '20px'
                            },
                            children=[
                                html.Div(
                                    style={'width': '50%', 'display': 'flex', 'flexDirection': 'column',
                                           'alignItems': 'center'},
                                    children=[
                                        # add point load button and dynamic loads
                                        html.Button("+ Point Load", id="add-point-load", n_clicks=0,
                                                    style=button_style),
                                        html.Div(id="point-container", children=[]),
                                    ]
                                ),
                                # vertical line to separate the load types
                                html.Div(
                                    style={
                                        'width': '2px',
                                        'backgroundColor': '#A6B1E1',
                                        'height': '100%',  # Full height of the container
                                        'margin': '0 40px'
                                    }
                                ),
                                # add uniform load button and dynamic loads
                                html.Div(
                                    style={'width': '50%', 'display': 'flex', 'flexDirection': 'column',
                                           'alignItems': 'center'},
                                    children=[
                                        html.Div(
                                            [
                                                # Information Button
                                                html.Button("i", id="info-button", n_clicks=0,
                                                            style={'fontSize': '10px', 'border-radius': '50%'}),
                                                html.Button("+ Uniform Load", id="add-uniform-load", n_clicks=0,
                                                            style={
                                                                'backgroundColor': '#5072a7',
                                                                'color': '#000000',
                                                                'border': 'none',
                                                                'padding': '10px 20px',
                                                                'borderRadius': '10px',
                                                                'cursor': 'pointer',
                                                                'fontSize': '16px',
                                                                'marginTop': '40px',
                                                                'marginBottom': '20px',
                                                                'margin-left': '5px',
                                                                'alignSelf': 'center',
                                                                'width': '150px'}),
                                            ]),
                                        # dynamic uniform load container
                                        html.Div(id="uniform-container", children=[]),
                                    ]
                                )
                            ]
                        )
                    ]
                ),
                # horizontal seperator line
                html.Hr(
                    style={
                        'borderColor': '#A6B1E1',
                        'borderWidth': '1px',
                        'width': '100%',
                        'margin': '20px 0'
                    }
                ),  # Separator Line

                html.Div(
                    className='animated-header-1',
                    style={"display": "flex", "flexDirection": "column", "alignItems": "center",
                           "justifyContent": "top"},
                    children=[
                        html.H2('Beam Properties',
                                style=
                                {'textDecoration': 'underline',
                                 'color': '#A6B1E1',
                                 'marginBottom': '15px',
                                 'textAlign': 'center'
                                 }
                                ),
                        # Two Buttons (Manual Design and Automatic Design)
                        html.Div(
                            children=[
                                html.Button('Manual Design', id='manual-design-btn', n_clicks=0,
                                            style={
                                                'background-color': '#8FA6F0',
                                                'color': 'black',
                                                'border': 'none',
                                                'padding': '20px 40px',
                                                'border-radius': '10px',
                                                'font-size': '18px',
                                                'cursor': 'pointer',
                                                'transition': '0.3s ease'
                                            }
                                            ),
                                html.Button('Automatic Design', id='automatic-design-btn', n_clicks=0,
                                            style={
                                                'background-color': '#8FA6F0',
                                                'color': 'black',
                                                'border': 'none',
                                                'padding': '20px 40px',
                                                'border-radius': '10px',
                                                'font-size': '18px',
                                                'cursor': 'pointer',
                                                'transition': '0.3s ease',
                                                'margin-left': '20px'
                                            }
                                            ),
                            ],
                            style={
                                'display': 'flex',
                                'justify-content': 'center',
                                'gap': '20px',
                                'margin-top': '50px'
                            }
                        ),

                        # Display section based on which button was clicked
                        html.Div(id='output-container', className='animated-header-1', style={'margin-top': '20px'}),

                    ]
                ),
            ]
        ),

        # Right Column (65%)
        html.Div(
            className='animated-header-1',
            style={
                'width': '65%',
                'padding': '20px',
                'backgroundColor': '#E8EEF7',
                'overflowY': 'auto',
                'display': 'flex',
                'flexDirection': 'column',
                'justifyContent': 'flex-start'
            },
            children=[
                html.H3('Design Summary', style={'textAlign': 'center'}),
                dash_table.DataTable(
                    id='data-table',
                    columns=[{'name': i, 'id': i} for i in df.columns],
                    data=df.to_dict('records'),
                    style_cell={'textAlign': 'center'},
                    style_table={'width': '50%', 'margin': 'auto'}
                ),
                html.H3('Beam Diagram', style={'textAlign': 'center'}),
                dcc.Graph(id='beam-graph', style={'border': '2px solid #2B3A67', 'padding': '5px'}),
                html.H3('Deflection Diagram', style={'textAlign': 'center'}),
                dcc.Graph(id='deflection-graph', style={'border': '2px solid #2B3A67'}),
                html.H3('Shear Diagram', style={'textAlign': 'center'}),
                dcc.Graph(id='force-graph', style={'border': '2px solid #2B3A67'}),
                html.H3('Moment Diagram', style={'textAlign': 'center'}),
                dcc.Graph(id='moment-graph', style={'border': '2px solid #2B3A67'}),
                html.Br(),
                html.Br()

            ]
        )
    ]
)


# callback to add support spacing inputs
@app.callback(
    Output('input-boxes', 'children'),
    Input('support-dropdown', 'value'),

)
def update_spacing_inputs(n_supports):
    inputs = []
    # Create input fields for the spacing between each pair of supports
    for i in range(n_supports - 1):
        inputs.append(html.Div([
            html.Label(f'{chr(65 + i)} - {chr(65 + i + 1)} : ', style={**label_style}),
            dcc.Input(
                id={'type': 'input-box', 'index': i + 1},
                type='number',
                value=5,  # Default value is 5 ft
                min=1,
                style={**input_style, 'width': '50px', 'margin-left': '5px'}
            ),
            html.Span("ft", style={**label_style, 'margin-left': '5px'}),
        ], className='animated-header-1',
            style={'display': 'flex', 'align-items': 'center', 'justify-content': 'center'}))
    return inputs


# managing point load list
@app.callback(
    Output("point-container", "children"),
    [
        Input("add-point-load", "n_clicks"),
        Input({"type": "dynamic-delete", "index": ALL}, "n_clicks"),
    ],
    [State("point-container", "children")],
)
def display_point_loads(add_clicks, delete_clicks, loads):
    triggered = callback_context.triggered_id

    if triggered == "add-point-load":
        load_number = len(loads) + 1
        new_element = html.Div(
            id={"type": "load", "index": load_number},
            children=[
                html.Div(

                    children=[
                        html.Span(f"P{load_number} =", style={'margin-right': '10px', 'font-weight': 'bold'}),
                        # "Load" input field
                        dcc.Input(type="number", id={"type": "point-load-value", "index": load_number}, value=0,
                                  style={**input_style, 'width': '50px'}),
                        html.Span("kip",
                                  style={'margin-left': '5px', 'margin-right': '15px', 'font-weight': 'bold'}), ],
                    style={"display": "inline-block"}),

                html.Div(

                    children=[
                        # "x=" input field
                        html.Span(f"x{load_number} =", style={'margin-right': '10px', 'font-weight': 'bold'}),
                        dcc.Input(type="number", id={"type": "point-load-x", "index": load_number}, value=0, min=0,
                                  style={**input_style, 'width': '50px'}),
                        html.Span("ft", style={'margin-left': '5px', 'font-weight': 'bold'}), ],
                    style={"display": "inline-block"}),

                dbc.Button(
                    "ðŸ—‘ï¸",  # Trash icon,
                    id={"type": "dynamic-delete", "index": load_number},
                    n_clicks=0,
                    color="danger", size="sm",
                    style={**delete_button_style, 'borderRadius': '2px', 'margin-left': '40px'}
                ),
            ], className='animated-header-1',
            style={
                "width": "80%",
                # "display": "inline-block",
                'border': "2px solid #A6B1E1",
                "padding": 10,
                "fontSize": '12px',
                'align-items': 'center'

            },
        )
        loads.append(new_element)

    elif triggered and triggered["type"] == "dynamic-delete":
        # print('delete was clicked')
        index_to_delete = triggered["index"]
        loads = [load for load in loads if load["props"]["id"]["index"] != index_to_delete]

        # re-label the remaining loads
        for i, load in enumerate(loads):
            # print(load["props"]["children"][2]["props"]["id"]["index"])
            # print(len(loads))
            load["props"]["children"][0]["props"]["children"][0]["props"]["children"] = f"P{i + 1}="
            load["props"]["children"][1]["props"]["children"][0]["props"]["children"] = f"x{i + 1} ="
            load["props"]["id"]["index"] = i + 1
            load["props"]["children"][2]["props"]["id"]["index"] = i + 1

    return loads


# callback to handle new and deleted uniform loads
@app.callback(
    Output("uniform-container", "children"),
    [
        Input("add-uniform-load", "n_clicks"),
        Input({"type": "dynamic-u-delete", "index": ALL}, "n_clicks"),
    ],
    [State("uniform-container", "children")],
)
def display_uniform_loads(add_clicks, delete_clicks, loads):
    # Determine the triggered button
    triggered = callback_context.triggered_id

    if triggered == "add-uniform-load":
        load_number = len(loads) + 1
        new_element = html.Div(
            id={"type": "u-load", "index": load_number},

            children=[
                html.Div(

                    children=[
                        html.Span(f"w{load_number} =", style={'margin-right': '40px', 'font-weight': 'bold'}),
                        # "Load" input field
                        dcc.Input(type="number", id={"type": "uniform-load-value", "index": load_number}, value=0,
                                  style={**input_style, 'width': '50px'}),
                        html.Span("kip/ft", style={'margin-left': '5px', 'font-weight': 'bold'}), ],
                    style={"display": "inline-block", 'margin-bottom': '8px'}),

                html.Div(

                    children=[
                        # "x_start=" input field
                        html.Span(f"x{load_number} begin =", style={'margin-right': '5px', 'font-weight': 'bold'}),
                        dcc.Input(type="number", id={"type": "uniform-x-start", "index": load_number}, value=0, min=0,
                                  style={**input_style, 'width': '50px'}),
                        html.Span("ft", style={'margin-left': '5px', 'margin-right': '15px', 'font-weight': 'bold'}), ],
                    style={"display": "inline-block", 'margin-bottom': '2px'}),

                html.Div(

                    children=[
                        # "x_end=" input field
                        html.Span(f"x{load_number} end =", style={'margin-right': '15px', 'font-weight': 'bold'}),
                        dcc.Input(type="number", id={"type": "uniform-x-end", "index": load_number}, value=0, min=0,
                                  style={**input_style, 'width': '50px'}),
                        html.Span("ft", style={'margin-left': '5px', 'font-weight': 'bold'}), ],
                    style={"display": "inline-block"}),

                dbc.Button(
                    "ðŸ—‘ï¸",  # Trash icon
                    id={"type": "dynamic-u-delete", "index": load_number},
                    n_clicks=0,
                    color="danger", size="sm",
                    style={**delete_button_style, 'borderRadius': '2px', 'margin-left': '60px'}
                ),
            ], className='animated-header-1',
            style={
                "width": "90%",
                "display": "inline-block",
                'border': "2px solid #A6B1E1",
                "padding": 10,
                "fontSize": '12px',
                'align-items': 'center'
            },
        )
        loads.append(new_element)
        print(f'current add_uniform click count is{load_number}')

    elif triggered and triggered["type"] == "dynamic-u-delete":
        print('delete was clicked')
        index_to_delete = triggered["index"]
        loads = [load for load in loads if load["props"]["id"]["index"] != index_to_delete]

        # re-label the remaining loads
        for i, load in enumerate(loads):
            print(load["props"]["children"][3]["props"]["id"]["index"])
            print(len(loads))
            load["props"]["children"][0]["props"]["children"][0]["props"]["children"] = f"w{i + 1}="
            load["props"]["children"][1]["props"]["children"][0]["props"]["children"] = f"x{i + 1} begin="
            load["props"]["children"][2]["props"]["children"][0]["props"]["children"] = f"x{i + 1} end="
            load["props"]["id"]["index"] = i + 1
            load["props"]["children"][3]["props"]["id"]["index"] = i + 1

    return loads


# update the max input value for the point load x
@app.callback(
    Output({"type": "point-load-x", "index": ALL}, 'max'),
Output({"type": "point-load-x", "index": ALL}, 'value'),
    Input({'type': 'input-box', 'index': ALL}, 'value'),
    Input({"type": "point-load-x", "index": ALL}, 'value')
)
def update_load_max(spacing_values, load_values):
    total_spacing_sum = sum(spacing_values) if spacing_values else 0
    # Return a list where each load-input gets the same max value
    return [total_spacing_sum for _ in load_values],[total_spacing_sum if _>total_spacing_sum else _ for _ in load_values]


# update the max input value for the uniform load x_end to be beam length

@app.callback(
    Output({"type": "uniform-x-end", "index": ALL}, 'max'),
    Output({"type": "uniform-x-end", "index": ALL}, 'value'),
    Input({'type': 'input-box', 'index': ALL}, 'value'),
    Input({"type": "uniform-x-end", "index": ALL}, 'value')
)
def update_u_load_max(spacing_values, load_values):
    total_spacing_sum = sum(spacing_values) if spacing_values else 0
    return [total_spacing_sum for _ in load_values], [total_spacing_sum if _>total_spacing_sum else _ for _ in load_values]


# update the min input value for the uniform load x_end to be the value of x_start

@app.callback(
    Output({"type": "uniform-x-end", "index": MATCH}, 'min'),
    Input({"type": "uniform-x-start", "index": MATCH}, 'value'),
)
def update_u_load_end_min(end_min):
    return end_min


# update the max input value for the uniform load x_start to be the value in x_end
@app.callback(
    Output({"type": "uniform-x-start", "index": MATCH}, 'max'),
    Input({"type": "uniform-x-end", "index": MATCH}, 'value'),
)
def update_load_max(start_max):
    return start_max


# Callback to show/hide popup cloud that is accessed when information/x button is clicked
@app.callback(
    [Output('modal', 'style'),
     Output('modal-content', 'style')],
    [Input('info-button', 'n_clicks'),
     Input('close-modal', 'n_clicks')],
    [State('modal', 'style')]  # This helps track the current modal visibility
)
def toggle_modal(info_clicks, close_clicks, modal_style):
    # If the modal is already visible and close button is clicked, hide the modal
    # If the info button is clicked and modal is not visible, show the modal
    if info_clicks > 0 and modal_style['display'] == 'none':
        return {'display': 'block'}, {'backgroundColor': 'white', 'padding': '20px', 'borderRadius': '10px',
                                      'width': '400px', 'position': 'relative', 'top': '50%', 'left': '50%',
                                      'transform': 'translate(-50%, -50%)', 'boxShadow': '0 4px 8px rgba(0, 0, 0, 0.1)'}


    elif close_clicks > 0:
        return {'display': 'none'}, {'display': 'none'}


    else:
        # If the info button is clicked but modal is already visible, just keep it open
        return modal_style, {'display': 'none'}  # Keep modal open or closed as per state


# Callback to update button styles and fade in the output text
@app.callback(
    [
        Output('manual-design-btn', 'style'),
        Output('automatic-design-btn', 'style'),
        Output('output-container', 'children'),
    ],
    [Input('manual-design-btn', 'n_clicks'),
     Input('automatic-design-btn', 'n_clicks')],
    [State('manual-design-btn', 'style'),
     State('automatic-design-btn', 'style')]
)
def update_button_style(manual_clicks, automatic_clicks, manual_style, automatic_style):
    ctx = dash.callback_context

    if not ctx.triggered:
        button_id = 'None'
    else:
        button_id = ctx.triggered[0]['prop_id'].split('.')[0]

    # Default styles for both buttons
    base_style = {
        'background-color': '#8FA6F0',
        'color': 'black',
        'border': 'none',
        'padding': '20px 40px',
        'border-radius': '10px',
        'font-size': '18px',
        'cursor': 'pointer',
        'transition': '0.5s ease',
        'transform': 'scale(1.1)'
    }

    # Apply fade effect for the button that was **NOT** clicked
    faded_style = {
        'background-color': '#B0B9E8',  # Lighter shade of blue
        'color': '#666',  # Faded text color
        'border': 'none',
        'padding': '20px 40px',
        'border-radius': '10px',
        'font-size': '18px',
        'cursor': 'pointer',
        'transition': '0.5s ease',
        'transform': 'scale(0.9)'
    }

    if button_id == 'manual-design-btn':
        manual_style = base_style
        automatic_style = faded_style
        beam_properties_display = html.Div(
            [
                html.P(
                    'Choose the Beam Material Type , Modulus of Elasticity, Moment of Inertia. Alternatively, You can select beam shape from list.',
                    style={
                        'fontSize': '16px',
                        'textAlign': 'center',
                        'marginBottom': '60px',
                        'color': '#A6B1E1'
                    }
                ),
                html.Label('Material', style={'margin-left': '22px', 'fontWeight': 'bold', 'color': '#A6B1E1',
                                              'text-align': 'center'}),
                dcc.Dropdown(
                    id='material-dropdown',
                    options=['None', 'Steel', 'Wood', 'Reinforced Concrete'],
                    value='None',  # Default value
                    clearable=False,
                    style=dropdown_style
                ),
                # container for material inputs
                html.Div(id='material-input-boxes', style={'margin-bottom': '30px', 'textAlign': 'center', }),
            ],
            className=f'animated-header-1',
            style={"display": "flex", "flexDirection": "column", "alignItems": "center", "justifyContent": "top"},
        )


    elif button_id == 'automatic-design-btn':
        manual_style = faded_style
        automatic_style = base_style
        beam_properties_display = html.Div(
            [
                html.P(
                    'Select Material type and see optimal beam selection. add constraints to the design to fit your project needs',
                    style={
                        'fontSize': '16px',
                        'textAlign': 'center',
                        'marginBottom': '60px',
                        'color': '#A6B1E1'
                    }
                ),
                html.Label('Material',
                           style={'margin-left': '22px', 'fontWeight': 'bold', 'color': '#A6B1E1',
                                  'text-align': 'center'}),
                dcc.Dropdown(
                    id='material-dropdown',
                    options=['None', 'Steel', 'Wood', 'Reinforced Concrete'],
                    value='None',  # Default value
                    clearable=False,
                    style=dropdown_style
                ),
            ],
            className='animated-header-1',
            style={"display": "flex", "flexDirection": "column", "alignItems": "center", "justifyContent": "top"},
        )
    else:
        beam_properties_display = 'Select a design option above'
    return manual_style, automatic_style, beam_properties_display


# callback to update beam diagram, force diagras, and design summary table


@app.callback(
    [Output('beam-graph', 'figure'),
     Output('force-graph', 'figure'),
     Output('moment-graph', 'figure'),
     Output('deflection-graph', 'figure'),
     Output('data-table', 'data')],
    [Input('support-dropdown', 'value'),
     Input({'type': 'input-box', 'index': ALL}, 'value'),
     Input('left-dropdown', 'value'),
     Input('right-dropdown', 'value'),
     Input({"type": "point-load-value", "index": ALL}, 'value'),
     Input({"type": "point-load-x", "index": ALL}, 'value'),
     Input({"type": "uniform-load-value", "index": ALL}, 'value'),
     Input({"type": "uniform-x-start", "index": ALL}, 'value'),
     Input({"type": "uniform-x-end", "index": ALL}, 'value'),
     Input('force-dropdown', 'value')
     # Input('force-graph', 'hoverData')
     ],
    [State("point-container", 'children'),
     State('uniform-container', 'children'),
     State('data-table', 'data')]
)
def update_beam(n_supports, values, left, right, point_value, point_x, u_value, u_xs, u_xe, force, point_loads, u_loads,
                summary_table):
    # create a list of current support spacings
    spacings = [i if i is not None else 0 for i in values]
    spacings.insert(0, 0)

    # pull all the existing point load labels, values, and x positions. handling
    point_load_labels = np.array([load["props"]["children"][0]["props"]["children"][0]["props"]["children"] if
                                  load["props"]["children"][0]["props"]["children"][0]["props"][
                                      "children"] is not None else 0 for i, load in enumerate(point_loads)])
    point_load_values = np.array([load["props"]["children"][0]["props"]["children"][1]["props"]['value'] if
                                  load["props"]["children"][0]["props"]["children"][1]["props"][
                                      'value'] is not None else 0 for load in point_loads])
    point_load_x = np.array([load["props"]["children"][1]["props"]["children"][1]["props"]['value'] if
                             load["props"]["children"][1]["props"]["children"][1]["props"]['value'] is not None else 0
                             for load in point_loads])

    # pull all the existing uniform load labels,values,x_start,x_end
    uniform_load_labels = np.array([load["props"]["children"][0]["props"]["children"][0]["props"]["children"] if
                                    load["props"]["children"][0]["props"]["children"][0]["props"][
                                        "children"] is not None else 0 for load in u_loads])
    uniform_load_values = np.array([load["props"]["children"][0]["props"]["children"][1]["props"]['value'] if
                                    load["props"]["children"][0]["props"]["children"][1]["props"][
                                        'value'] is not None else 0 for load in u_loads])
    uniform_load_x_begin = np.array([load["props"]["children"][1]["props"]["children"][1]["props"]['value'] if
                                     load["props"]["children"][1]["props"]["children"][1]["props"][
                                         'value'] is not None else 0 for load in u_loads])
    uniform_load_x_end = np.array([load["props"]["children"][2]["props"]["children"][1]["props"]['value'] if
                                   load["props"]["children"][2]["props"]["children"][1]["props"][
                                       'value'] is not None else 0 for load in u_loads])

    return create_beam_figure(n_supports, spacings, left, right, point_load_labels, point_load_values, point_load_x,
                              uniform_load_labels, uniform_load_values, uniform_load_x_begin, uniform_load_x_end,
                              force, point_loads, u_loads, summary_table)


def create_beam_figure(n_supports, spacings, left, right, point_load_labels, point_load_values, point_load_x,
                       uniform_load_labels,
                       uniform_load_values, uniform_load_x_begin, uniform_load_x_end, force, point_loads,
                       u_loads, summary_table):
    # =====================
    # Update Beam Diagram
    # =====================
    start_time_B = time.time()
    beam_length = sum(spacings)  # Total length based on number of supports and spacing
    L=beam_length
    beam_x = [0, beam_length]
    beam_y = [0, 0]

    # Beam line
    beam_trace = go.Scatter(
        x=beam_x,
        y=beam_y,
        mode='lines',
        line=dict(color='#000080', width=5),
        name='Beam',
    )

    # The supports are all going to be simple supports except potentially the end supports.
    support_types = ['Simple', 'Moment', 'None (Overhang)']
    # Supports as triangles
    support_traces = []
    support_width = beam_length/30  # width of the base of the triangle. note it is a function of beam length so it is plotted consistently
    support_height = .5  # height of the triangle

    # Calculate positions of supports relative to left end
    support_positions = []
    current = 0
    for i in spacings:
        current += i
        support_positions.append(current)

    # add supports to beam
    for idx, sx in enumerate(support_positions):
        if sx == 0:  # begin support
            if left == support_types[0]:  # left end support is simple (triangle support)
                support_traces.append(go.Scatter(
                    x=[sx - support_width / 2, sx + support_width / 2, sx, sx - support_width / 2],
                    y=[-support_height, -support_height, 0, -support_height],
                    mode='lines',
                    fill='toself',
                    fillcolor='#8B0000',
                    line=dict(color='black'),
                    name='Support',
                    hoverinfo='none'  # No hover info for supports
                ))
            elif left == support_types[1]:  # left end support is moment (rectangle support)
                support_traces.append(go.Scatter(
                    x=[sx - support_width / 4, sx, sx, sx - support_width / 4, sx - support_width / 4],
                    y=[+support_height, +support_height, -support_height, -support_height, +support_height],
                    mode='lines',
                    fill='toself',
                    fillcolor='#8B0000',
                    line=dict(color='black'),
                    name='Support',
                    hoverinfo='none'  # No hover info for supports
                ))

        elif sx == beam_length:  # end support
            if right == support_types[0]:  # right end support is simple (triangle support)
                support_traces.append(go.Scatter(
                    x=[sx - support_width / 2, sx + support_width / 2, sx, sx - support_width / 2],
                    y=[-support_height, -support_height, 0, -support_height],
                    mode='lines',
                    fill='toself',
                    fillcolor='#8B0000',
                    line=dict(color='black'),
                    name='Support',
                    hoverinfo='none'  # No hover info for supports
                ))
            elif right == support_types[1]:  # right end support is moment (rectangle support)
                support_traces.append(go.Scatter(
                    x=[sx + support_width / 4, sx, sx, sx + support_width / 4, sx + support_width / 4],
                    y=[+support_height, +support_height, -support_height, -support_height, +support_height],
                    mode='lines',
                    fill='toself',
                    fillcolor='#8B0000',
                    line=dict(color='black'),
                    name='Support',
                    hoverinfo='none'  # No hover info for supports
                ))

        else:  # all  middle supports
            support_traces.append(go.Scatter(
                x=[sx - support_width / 2, sx + support_width / 2, sx, sx - support_width / 2],
                y=[-support_height, -support_height, 0, -support_height],
                mode='lines',
                fill='toself',
                fillcolor='#8B0000',
                line=dict(color='black'),
                name='Support',
                hoverinfo='none'  # No hover info for supports
            ))

    # Supports Labels
    SUPPORT_LABELS = list("ABCDEFGHIJ")  # Labels from A to J for supports 1 to 10
    label_traces = []
    for idx, sx in enumerate(support_positions):
        label = SUPPORT_LABELS[idx]

        # Position the label slightly below the support
        label_x = sx
        label_y = -support_height - 0.25  # Adjust the y-position as needed

        label_traces.append(go.Scatter(
            x=[label_x],
            y=[label_y],
            mode='text',
            text=f'<b>{label}<b>',
            textposition='top center',
            textfont=dict(size=12, color='black'),
            showlegend=False,
            hoverinfo='none'
        ))

    # Add two-sided arrows between supports, and the loads in an array called annotations
    annotations = []
    for i, j in zip(range(len(support_positions) - 1), range(len(spacings) - 1)):
        start_x = support_positions[i]
        end_x = support_positions[i + 1]
        mid_x = (start_x + end_x) / 2  # Middle point for the text

        # create a two-way arrow that shows the spacing between supports
        # Create annotation for left to right arrow
        annotations.append(dict(
            ax=start_x + .25*L/15, ay=-.7,  # Start point of the arrow
            x=end_x - .25*L/15, y=-.7,  # End point of the arrow
            xref='x', yref='y',
            showarrow=True,
            arrowhead=2,  # Two-sided arrow
            arrowsize=1.5,
            arrowwidth=1.5,
            axref='x', ayref='y',
            standoff=4
        ))
        # Create annotation for right to left arrow
        annotations.append(dict(
            ax=end_x - .25*L/15, ay=-.7,  # Start point of the arrow
            x=start_x + .25*L/15, y=-.7,  # End point of the arrow
            xref='x', yref='y',
            showarrow=True,
            arrowhead=2,  # Two-sided arrow
            arrowsize=1.5,
            arrowwidth=1.5,
            axref='x', ayref='y',
            standoff=4
        ))

        # Text "j ft" at the center of the arrow
        annotations.append(dict(
            x=mid_x, y=-1,  # Position text slightly below the arrow
            xref='x', yref='y',
            text=f'<b>{spacings[j + 1]} ft<b>',
            showarrow=False,
            font=dict(size=12, color='black')
        ))

        # place the uniform loads on the beam. note this is drawn before point loads to allow point loads to be drawn over uniform loads, for clarity.
        #in order that the uniform load spacing is clean and even regardless of beam size, a function will be used to determine the optimal spacing:
        if uniform_load_x_end.ndim != 0: #ensures uniform loads are only placed when there is a length to them
            def find_closest_i(x, B):
                # Calculate target value for i
                target_i = 0.025 * B

                # Find all divisors of x
                divisors = [i for i in range(1, x + 1) if x % i == 0]

                # Filter divisors to those <= B
                valid_divisors = [i for i in divisors if i <= B]

                # Find the divisor closest to target_i
                closest_i = min(valid_divisors, key=lambda i: abs(i - target_i))

                return closest_i
            for i, j, k, l in zip(uniform_load_labels, uniform_load_values, uniform_load_x_begin, uniform_load_x_end):
                label, w, xs, xe = i, j, k, l
                for x in np.arange(xs, xe + find_closest_i(xe-xs,beam_length), find_closest_i(xe-xs,beam_length)):
                    annotations.append(dict(
                        x=x,
                        y=0.1,
                        xref="x",
                        yref="y",
                        showarrow=True,
                        arrowhead=2,
                        ax=0,
                        ay=-40,
                        arrowcolor="orange",
                        arrowwidth=2
                    ))
                # horizontal line connecting arrows to make uniform display
                annotations.append(dict(
                    ax=xs - .05, ay=.6,  # Start point of the arrow
                    x=xe, y=.6,  # End point of the arrow
                    xref='x', yref='y',
                    showarrow=True,
                    arrowhead=0,  # 0-sided arrow
                    arrowsize=1.5,
                    arrowcolor="orange",
                    arrowwidth=2,
                    axref='x', ayref='y',
                    standoff=0,
                ))
                # text for uniform load
                annotations.append(dict(
                    x=(xs + xe) / 2, y=.8,  # Position text slightly above the uniform load
                    xref='x', yref='y',
                    text=f'<b>{i}{j} k/ft<b>',
                    showarrow=False,
                    font=dict(size=12, color='black')
                ))
        else:
            pass
        # place the point loads in the beam
        for i, j, k in zip(point_load_labels, point_load_values, point_load_x):
            label, P, x = i, j, k
            # Add a vertical arrow at the x position
            annotations.append(dict(
                x=x,
                y=0.1,
                xref="x",
                yref="y",
                text=f"<b>{i}{j} kip<b>",
                showarrow=True,
                arrowhead=2,
                ax=0,
                ay=-80,
                arrowcolor="red",
                arrowwidth=2,
                font=dict(size=12, color='black')
            ))

    # Solve for beam reactions to display on the beam diagram
    # the first step is solving for the beam reactions based on the applied loads.
    # the chosen method of analysis will be superposition for supports 3 or greater. for 2 supports, deflection tables will be used directly (referenced in AISC Manual)
    # for each point load on the beam , an array of the support reactions will be created.
    # then all the reactions will be added up to get the actual reactions.
    end_time_B = time.time()  # End timing
    print(f" beam diagram creation time: {end_time_B - start_time_B:.4f} seconds")
    start_time_R= time.time()
    analysis_type = ['Shear Diagram', 'Moment Diagram']
    stability = True  # default assumption unless user makes supports unstable
    completion = False  # tracks my progress as to which influence lines are available to user
    print(f'point loads are {point_load_values} and uniform loads are {uniform_load_values}')
    MA = 0  # initial end moment value
    MB = 0  # initial end moment value
    x_diagram = np.arange(0, beam_length + .01, .01)


    if point_load_values.size == 0 and uniform_load_values.size == 0:  # there are no load cases
        print('no loads detected')
        All_Reactions = np.array([0 for i in support_positions])
        x_diagram = np.arange(0, beam_length + .01, .01)
        V = np.zeros_like(x_diagram)
        M = np.zeros_like(x_diagram)
        D= np.zeros_like(x_diagram)
        MA = 0  # initial end moment value
        MB = 0  # initial end moment value


    else:  # there are load cases
        if n_supports >= 3:

            if left == support_types[0] and right == support_types[0]:  # pinned on both sides
                mid_positions = [support_positions[i] for i in
                                 range(1, len(support_positions) - 1)]  # only positions of middle supports

                def create_solve_sys_equations(positions, force, i):
                    # the deflections caused by point load at the middle supports will fill the B matrix (constants)
                    # the deflections caused by the reaction forces at the middle supports will fill A matrix (coefficients)
                    # positions is the support positions , and load_position is the point load position (measured from far left)
                    mid_positions = [positions[i] for i in
                                     range(1, len(positions) - 1)]  # only positions of middle supports
                    L = beam_length

                    #determine the equations needed based on the edge conditions. all based on point load cases found in deflection tables

                    B = np.array(
                        [force * (L - i) * p / (6 * L) * (L ** 2 - (L - i) ** 2 - p ** 2) if p < i else force * (
                            i) * (L - p) / (6 * L) * (L ** 2 - (i) ** 2 - (L - p) ** 2)for p in mid_positions])
                    C = np.array(
                        [[(L - j) * p / (6 * L) * (L ** 2 - (L - j) ** 2 - p ** 2) if p < j else (j) * (L - p) / (
                                6 * L) * (L ** 2 - (j) ** 2 - (L - p) ** 2) for p in mid_positions] for j in
                         mid_positions])
                    A = np.array([[C[k][m] for k in range(0, len(C))] for m in range(0, len(C))])
                    # Solve the system of equations
                    try:
                        solution = np.linalg.solve(A, B)
                        rounded_solution = np.round(solution, 6)
                        return rounded_solution
                    except np.linalg.LinAlgError:  # this will only occur if there are no middle reactions (2 support beam), hence an empty A matrix
                        return np.array([])

                # create a list of all the middle support reactions for every point load:
                L = beam_length
                start_time = time.time()  # End timing
                P_Reactions = np.array(
                    [create_solve_sys_equations(support_positions, i, j) for i, j in
                     zip(point_load_values, point_load_x)])
                print(f'Point Reactions={P_Reactions}')
                # additionally, the uniform loads will use the same method as the point loads to solve the Reactions, separating the uniform load
                # into smaller point loads spaced at a specific interval
                interval = .01  # this will match the shear/moment diagram interval
                u_load_conversion = np.array(
                    [i * interval for i in uniform_load_values])  # uniform load array with point load equivalent

                # Create ranges for each load using a list comprehension
                ranges = [np.arange(start + interval, end + interval, interval) for start, end in
                          zip(uniform_load_x_begin, uniform_load_x_end)]
                U_Reactions = []
                print(
                    f'the active iterated uniform load values are{u_load_conversion} and x-start values are {uniform_load_x_begin} and x_end values are{uniform_load_x_end}')
                for i, j in enumerate(u_load_conversion):
                    for k in ranges[i]:
                        U_conversion_Reaction = np.array([create_solve_sys_equations(support_positions, j,
                                                                                     k)])  # this will run the S.O.E for each iterated uniform load "point" equivalent
                        # print(f'the middle reactions for the u_value={j} @x={k}ft is {U_conversion_Reaction}')
                        U_Reactions.append(create_solve_sys_equations(support_positions, j, k))
                U_Reactions = np.array(U_Reactions)
                print(f'Uniform Reactions are {U_Reactions}')
                Total_Reactions = np.array(np.sum(P_Reactions, axis=0)) + np.array(np.sum(U_Reactions, axis=0))
                print(f'Total_Reactions={Total_Reactions}')
                print(Total_Reactions.ndim)


                # solve far left support by setting moment about far right support to zero:
                # solve support reaction moment about last support:
                if Total_Reactions.ndim != 0:  # ensures there are loads
                    M_Reactions = np.array([i * (L - j) for i, j in zip(Total_Reactions, mid_positions)])
                    print(f'M_Reactions={M_Reactions}')

                    M_Point_Loads = np.array([-i * (L - j) for i, j in zip(point_load_values, point_load_x)])

                    M_Uniform_Loads = np.array([-i * (k - j) * (L - (k - (k - j) / 2)) for i, j, k in
                                                zip(uniform_load_values, uniform_load_x_begin, uniform_load_x_end)])

                    Total_M = np.sum(M_Reactions) + np.sum(M_Point_Loads) + np.sum(M_Uniform_Loads)
                    print(f'Total Moment about last support excluding Ay={Total_M}')

                    A_y = -Total_M / L if Total_M != 0 else 0
                    A_y = round(A_y, 6)
                    print(A_y)

                    # solve last reaction
                    Last = sum(point_load_values) + sum([i * (k - j) for i, j, k in
                                                         zip(uniform_load_values, uniform_load_x_begin,
                                                             uniform_load_x_end)]) - np.sum(Total_Reactions) - A_y
                    Last = round(Last, 6)
                    All_Reactions = []
                    All_Reactions.append(A_y)
                    for i in Total_Reactions:
                        All_Reactions.append(i)
                    All_Reactions.append(Last)
                    All_Reactions = np.array(All_Reactions)
                    print(f'All Reactions={All_Reactions}')

                    #solve for deflection values using the known middle reactions, point loads, and uniform loads:
                    # Initialize arrays for R_D, P_D, and U_D with the size of x_diagram
                    # Discretize beam
                    # Initialize D as zero array with the size of x_diagram
                    D = np.zeros_like(x_diagram)

                    # Step 1: Compute R_D
                    for force, i in zip(Total_Reactions, mid_positions):
                        condition = x_diagram < i
                        R_D = np.where(
                            condition,
                            force * (L - i) * x_diagram / (6 * L) * (L ** 2 - (L - i) ** 2 - x_diagram ** 2),
                            force * i * (L - x_diagram) / (6 * L) * (L ** 2 - i ** 2 - (L - x_diagram) ** 2),
                        )
                        D += R_D  # Add to total

                    # Step 2: Compute P_D
                    for force, i in zip(point_load_values, point_load_x):
                        condition = x_diagram < i
                        P_D = np.where(
                            condition,
                            -force * (L - i) * x_diagram / (6 * L) * (L ** 2 - (L - i) ** 2 - x_diagram ** 2),
                            -force * i * (L - x_diagram) / (6 * L) * (L ** 2 - i ** 2 - (L - x_diagram) ** 2),
                        )
                        D += P_D  # Add to total

                    # Step 3: Compute U_D
                    for k, force in enumerate(u_load_conversion):
                        i_range = np.array(ranges[k])  # Convert range to array
                        for i in i_range:
                            condition = x_diagram < i
                            U_D = np.where(
                                condition,
                                -force * (L - i) * x_diagram / (6 * L) * (L ** 2 - (L - i) ** 2 - x_diagram ** 2),
                                -force * i * (L - x_diagram) / (6 * L) * (L ** 2 - i ** 2 - (L - x_diagram) ** 2),
                            )
                            D += U_D  # Add to total


                else:
                    All_Reactions = np.array(
                        [0 for i in support_positions])  # this is just a placeholder for the reactions


            elif left == support_types[0] and right == support_types[1]:  # pinned on left, fixed on right
                mid_positions = [support_positions[i] for i in
                                 range(1, len(support_positions) - 1)]  # only positions of middle supports

                def create_solve_sys_equations(positions, force, i):
                    # the deflections caused by point load at the middle supports will fill the B matrix (constants)
                    # the deflections caused by the reaction forces at the middle supports will fill A matrix (coefficients)
                    # positions is the support positions , and load_position is the point load position (measured from far left)
                    mid_positions = [positions[i] for i in
                                     range(1, len(positions) - 1)]  # only positions of middle supports
                    L = beam_length

                    # determine the equations needed based on the edge conditions. all based on point load cases found in deflection tables

                    B = np.array(
                        [force * (L - i) ** 2 * p / (12 * L ** 3) * (3 * i * L ** 2 - 2 * L * p ** 2 - i * p ** 2)if p < i
                         else force * i / (12 * L ** 3) * ((L-p) ** 2) * (3 * L ** 2 * p - p * i ** 2 - 2 * L * i ** 2)
                         for p in mid_positions])
                    C = np.array(
                        [[(L - j) ** 2 * p / (12 * L ** 3) * (3 * j * L ** 2 - 2 * L * p ** 2 - j * p ** 2) if p < j
                          else j / (12 * L ** 3) * ((L-p) ** 2) * (3 * L ** 2 * p - p * j ** 2 - 2 * L * j ** 2)
                          for p in mid_positions] for j in mid_positions])
                    A = np.array([[C[k][m] for k in range(0, len(C))] for m in range(0, len(C))])
                    # Solve the system of equations
                    try:
                        solution = np.linalg.solve(A, B)
                        rounded_solution = np.round(solution, 6)
                        #solve for left moment
                        return rounded_solution
                    except np.linalg.LinAlgError:  # this will only occur if there are no middle reactions (2 support beam), hence an empty A matrix
                        return np.array([])



                # create a list of all the middle support reactions for every point load:
                L = beam_length
                start_time = time.time()  # End timing
                P_Reactions = np.array(
                    [create_solve_sys_equations(support_positions, i, j) for i, j in
                     zip(point_load_values, point_load_x)])
                print(f'Point Reactions={P_Reactions}')
                # additionally, the uniform loads will use the same method as the point loads to solve the Reactions, separating the uniform load
                # into smaller point loads spaced at a specific interval
                interval = .01  # this will match the shear/moment diagram interval
                u_load_conversion = np.array(
                    [i * interval for i in uniform_load_values])  # uniform load array with point load equivalent

                # Create ranges for each load using a list comprehension
                ranges = [np.arange(start + interval, end + interval, interval) for start, end in
                          zip(uniform_load_x_begin, uniform_load_x_end)]
                U_Reactions = []
                print(
                    f'the active iterated uniform load values are{u_load_conversion} and x-start values are {uniform_load_x_begin} and x_end values are{uniform_load_x_end}')
                for i, j in enumerate(u_load_conversion):
                    for k in ranges[i]:
                        U_Reactions.append(create_solve_sys_equations(support_positions, j, k))
                U_Reactions = np.array(U_Reactions)
                print(f'Uniform Reactions are {U_Reactions}')
                Total_Reactions = np.array(np.sum(P_Reactions, axis=0)) + np.array(np.sum(U_Reactions, axis=0))
                print(f'Total_Reactions={Total_Reactions}')
                print(Total_Reactions.ndim)

                # solve far left support by summing all the RA values calculated by the equation from tables
                if Total_Reactions.ndim != 0:  # ensures there are loads
                    RA_Reactions = np.array([-i*(L-j)**2*(j+2*L)/(2*L**3) for i, j in zip(Total_Reactions, mid_positions)])
                    RB_Reactions= np.array([-i*(j)*(3*L**2-j**2)/(2*L**3) for i, j in zip(Total_Reactions, mid_positions)])
                    MB_Reactions= np.array([i*(j*(L-j))*(L+j)/(2*L**2) for i, j in zip(Total_Reactions, mid_positions)])

                    RA_Point_Loads = np.array([i*(L-j)**2*(j+2*L)/(2*L**3) for i, j in zip(point_load_values, point_load_x)])
                    RB_Point_Loads = np.array([i*(j)*(3*L**2-j**2)/(2*L**3) for i, j in
                                               zip(point_load_values, point_load_x)])
                    MB_Point_Loads = np.array([-i*(j*(L-j))*(L+j)/(2*L**2) for i, j in
                                               zip(point_load_values, point_load_x)])
                    RA_Uniform_Loads=[]
                    RB_Uniform_Loads=[]
                    MB_Uniform_Loads = []
                    for k, i in enumerate(u_load_conversion):
                        for j in ranges[k]:

                            RA_Uniform_Loads.append(i*(L-j)**2*(j+2*L)/(2*L**3))
                            RB_Uniform_Loads.append(i*(j)*(3*L**2-j**2)/(2*L**3))
                            MB_Uniform_Loads.append(-i*(j*(L-j))*(L+j)/(2*L**2))


                    RA_Uniform_Loads = np.array(RA_Uniform_Loads)
                    RB_Uniform_Loads = np.array(RB_Uniform_Loads)
                    MB_Uniform_Loads = np.array(MB_Uniform_Loads)
                    print(RA_Uniform_Loads)
                    RA = np.sum(RA_Reactions) + np.sum(RA_Point_Loads) + np.sum(RA_Uniform_Loads)
                    RB = np.sum(RB_Reactions) + np.sum(RB_Point_Loads) + np.sum(RB_Uniform_Loads)
                    MB = np.sum(MB_Reactions) + np.sum(MB_Point_Loads) + np.sum(MB_Uniform_Loads)

                    print(f'Total Moment about last support excluding Ay={RA}')

                    All_Reactions = []
                    All_Reactions.append(RA)
                    for i in Total_Reactions:
                        All_Reactions.append(i)
                    All_Reactions.append(RB)
                    All_Reactions = np.array(All_Reactions)
                    print(f'All Reactions={All_Reactions}')

                    # solve for deflection values using the known middle reactions, point loads, and uniform loads:
                    # Initialize arrays for R_D, P_D, and U_D with the size of x_diagram
                    # Discretize beam
                    # Initialize D as zero array with the size of x_diagram
                    D = np.zeros_like(x_diagram)

                    # Step 1: Compute R_D
                    for force, i in zip(Total_Reactions, mid_positions):
                        condition = x_diagram < i
                        R_D = np.where(
                            condition,
                            force * (L - i) ** 2 * x_diagram / (12 * L ** 3) * (3 * i * L ** 2 - 2 * L * x_diagram ** 2 - i * x_diagram ** 2),
                            force * i / (12 * L ** 3) * ((L-x_diagram) ** 2) * (3 * L ** 2 * x_diagram - x_diagram * i ** 2 - 2 * L * i ** 2),
                        )
                        D += R_D  # Add to total

                    # Step 2: Compute P_D
                    for force, i in zip(point_load_values, point_load_x):
                        condition = x_diagram < i
                        P_D = np.where(
                            condition,
                            -force * (L - i) ** 2 * x_diagram / (12 * L ** 3) * (3 * i * L ** 2 - 2 * L * x_diagram ** 2 - i * x_diagram ** 2),
                            -force * i / (12 * L ** 3) * ((L - x_diagram) ** 2) * (3 * L ** 2 * x_diagram - x_diagram * i ** 2 - 2 * L * i ** 2),
                        )
                        D += P_D  # Add to total

                    # Step 3: Compute U_D
                    for k, force in enumerate(u_load_conversion):
                        i_range = np.array(ranges[k])  # Convert range to array
                        for i in i_range:
                            condition = x_diagram < i
                            U_D = np.where(
                                condition,
                                -force * (L - i) ** 2 * x_diagram / (12 * L ** 3) * (3 * i * L ** 2 - 2 * L * x_diagram ** 2 - i * x_diagram ** 2),
                                -force * i / (12 * L ** 3) * ((L - x_diagram) ** 2) * (3 * L ** 2 * x_diagram - x_diagram * i ** 2 - 2 * L * i ** 2),
                            )
                            D += U_D  # Add to total


                else:
                    All_Reactions = np.array(
                        [0 for i in support_positions])  # this is just a placeholder for the reactions


            elif left == support_types[1] and right == support_types[0]:  # fixed on left, pinned on right
                mid_positions = [support_positions[i] for i in
                                 range(1, len(support_positions) - 1)]  # only positions of middle supports

                def create_solve_sys_equations(positions, force, i):
                    # the deflections caused by point load at the middle supports will fill the B matrix (constants)
                    # the deflections caused by the reaction forces at the middle supports will fill A matrix (coefficients)
                    # positions is the support positions , and load_position is the point load position (measured from far left)
                    mid_positions = [positions[i] for i in
                                     range(1, len(positions) - 1)]  # only positions of middle supports
                    L = beam_length

                    # determine the equations needed based on the edge conditions. all based on point load cases found in deflection tables

                    B = np.array(
                        [force * (i) ** 2 * (L-p) / (12 * L ** 3) * (3 * (L - i) * L ** 2 - 2 * L * (L-p) ** 2 - (L - i) * (L-p) ** 2) if (L-p) < (L-i)
                         else force * (L - i) / (12 * L ** 3) * (L-(L-p))** 2 * (3 * L ** 2 * (L-p) - (L-p) * (L - i) ** 2 - 2 * L * (L - i) ** 2)
                         for p in mid_positions])
                    C = np.array(
                        [[(j) ** 2 * (L-p) / (12 * L ** 3) * (3 * (L - j) * L ** 2 - 2 * L * (L-p) ** 2 - (L - j) * (L-p) ** 2) if (L-p) < (L-j)
                          else (L - j) / (12 * L ** 3) * (p ** 2) * (3 * L ** 2 * (L-p) - (L-p) * (L - j) ** 2 - 2 * L * (L - j) ** 2)
                          for p in mid_positions] for j in mid_positions])
                    A = np.array([[C[k][m] for k in range(0, len(C))] for m in range(0, len(C))])
                    # Solve the system of equations
                    try:
                        solution = np.linalg.solve(A, B)
                        rounded_solution = np.round(solution, 6)
                        #solve for left moment
                        return rounded_solution
                    except np.linalg.LinAlgError:  # this will only occur if there are no middle reactions (2 support beam), hence an empty A matrix
                        return np.array([])



                # create a list of all the middle support reactions for every point load:
                L = beam_length
                start_time = time.time()  # End timing
                P_Reactions = np.array(
                    [create_solve_sys_equations(support_positions, i, j) for i, j in
                     zip(point_load_values, point_load_x)])
                print(f'Point Reactions={P_Reactions}')
                # additionally, the uniform loads will use the same method as the point loads to solve the Reactions, separating the uniform load
                # into smaller point loads spaced at a specific interval
                interval = .01  # this will match the shear/moment diagram interval
                u_load_conversion = np.array(
                    [i * interval for i in uniform_load_values])  # uniform load array with point load equivalent

                # Create ranges for each load using a list comprehension
                ranges = [np.arange(start + interval, end + interval, interval) for start, end in
                          zip(uniform_load_x_begin, uniform_load_x_end)]
                U_Reactions = []
                print(
                    f'the active iterated uniform load values are{u_load_conversion} and x-start values are {uniform_load_x_begin} and x_end values are{uniform_load_x_end}')
                for i, j in enumerate(u_load_conversion):
                    for k in ranges[i]:
                        U_Reactions.append(create_solve_sys_equations(support_positions, j, k))
                U_Reactions = np.array(U_Reactions)
                print(f'Uniform Reactions are {U_Reactions}')
                Total_Reactions = np.array(np.sum(P_Reactions, axis=0)) + np.array(np.sum(U_Reactions, axis=0))
                print(f'Total_Reactions={Total_Reactions}')
                print(Total_Reactions.ndim)

                # solve far left support by summing all the RA values calculated by the equation from tables
                if Total_Reactions.ndim != 0:  # ensures there are loads
                    RA_Reactions = np.array([-i*(L-j)*(3*L**2-(L-j)**2)/(2*L**3)for i, j in zip(Total_Reactions, mid_positions)])
                    RB_Reactions = np.array([-i*(j)**2*((L-j)+2*L)/(2*L**3) for i, j in zip(Total_Reactions, mid_positions)])
                    MA_Reactions= np.array([i*(j*(L-j))*(L+(L-j))/(2*L**2) for i, j in zip(Total_Reactions, mid_positions)])

                    RA_Point_Loads = np.array([i*(L-j)*(3*L**2-(L-j)**2)/(2*L**3) for i, j in zip(point_load_values, point_load_x)])
                    RB_Point_Loads = np.array([i*(j)**2*((L-j)+2*L)/(2*L**3) for i, j in
                                               zip(point_load_values, point_load_x)])
                    MA_Point_Loads = np.array([-i*(j*(L-j))*(L+(L-j))/(2*L**2) for i, j in
                                               zip(point_load_values, point_load_x)])
                    RA_Uniform_Loads=[]
                    RB_Uniform_Loads=[]
                    MA_Uniform_Loads = []
                    for k, i in enumerate(u_load_conversion):
                        for j in ranges[k]:

                            RA_Uniform_Loads.append(i*(L-j)*(3*L**2-(L-j)**2)/(2*L**3))
                            RB_Uniform_Loads.append(i*(j)**2*((L-j)+2*L)/(2*L**3))
                            MA_Uniform_Loads.append(-i*(j*(L-j))*(L+(L-j))/(2*L**2))


                    RA_Uniform_Loads = np.array(RA_Uniform_Loads)
                    RB_Uniform_Loads = np.array(RB_Uniform_Loads)
                    MA_Uniform_Loads = np.array(MA_Uniform_Loads)
                    print(RA_Uniform_Loads)
                    RA = np.sum(RA_Reactions) + np.sum(RA_Point_Loads) + np.sum(RA_Uniform_Loads)
                    RB = np.sum(RB_Reactions) + np.sum(RB_Point_Loads) + np.sum(RB_Uniform_Loads)
                    MA = np.sum(MA_Reactions) + np.sum(MA_Point_Loads) + np.sum(MA_Uniform_Loads)

                    print(f'Total Moment about last support excluding Ay={RA}')

                    All_Reactions = []
                    All_Reactions.append(RA)
                    for i in Total_Reactions:
                        All_Reactions.append(i)
                    All_Reactions.append(RB)
                    All_Reactions = np.array(All_Reactions)
                    print(f'All Reactions={All_Reactions}')

                    # solve for deflection values using the known middle reactions, point loads, and uniform loads:
                    # Initialize arrays for R_D, P_D, and U_D with the size of x_diagram
                    # Discretize beam
                    # Initialize D as zero array with the size of x_diagram
                    D = np.zeros_like(x_diagram)

                    # Step 1: Compute R_D
                    for force, i in zip(Total_Reactions, mid_positions):
                        condition = (L-x_diagram) < (L-i)
                        R_D = np.where(
                            condition,
                            force * (i) ** 2 * (L-x_diagram) / (12 * L ** 3) * (3 * (L - i) * L ** 2 - 2 * L * (L-x_diagram) ** 2 - (L - i) * (L-x_diagram) ** 2),
                            force * (L - i) / (12 * L ** 3) * (x_diagram ** 2) * (3 * L ** 2 * (L-x_diagram) - (L-x_diagram) * (L - i) ** 2 - 2 * L * (L - i) ** 2),
                        )
                        D += R_D  # Add to total

                    # Step 2: Compute P_D
                    for force, i in zip(point_load_values, point_load_x):
                        condition = (L-x_diagram) < (L-i)
                        P_D = np.where(
                            condition,
                            -force * (i) ** 2 * (L - x_diagram) / (12 * L ** 3) * (3 * (L - i) * L ** 2 - 2 * L * (L - x_diagram) ** 2 - (L - i) * (L - x_diagram) ** 2),
                            -force * (L - i) / (12 * L ** 3) * (x_diagram ** 2) * (3 * L ** 2 * (L - x_diagram) - (L - x_diagram) * (L - i) ** 2 - 2 * L * (L - i) ** 2),
                        )
                        D += P_D  # Add to total

                    # Step 3: Compute U_D
                    for k, force in enumerate(u_load_conversion):
                        i_range = np.array(ranges[k])  # Convert range to array
                        for i in i_range:
                            condition = (L-x_diagram) < (L-i)
                            U_D = np.where(
                                condition,
                                -force * (i) ** 2 * (L - x_diagram) / (12 * L ** 3) * (3 * (L - i) * L ** 2 - 2 * L * (L - x_diagram) ** 2 - (L - i) * (L - x_diagram) ** 2),
                                -force * (L - i) / (12 * L ** 3) * (x_diagram ** 2) * (3 * L ** 2 * (L - x_diagram) - (L - x_diagram) * (L - i) ** 2 - 2 * L * (L - i) ** 2),
                            )
                            D += U_D  # Add to total


                else:
                    All_Reactions = np.array(
                        [0 for i in support_positions])  # this is just a placeholder for the reactions


            elif left == support_types[1] and right == support_types[1]:  # fixed on left, fixed on right
                mid_positions = [support_positions[i] for i in
                                 range(1, len(support_positions) - 1)]  # only positions of middle supports

                def create_solve_sys_equations(positions, force, i):
                    # the deflections caused by point load at the middle supports will fill the B matrix (constants)
                    # the deflections caused by the reaction forces at the middle supports will fill A matrix (coefficients)
                    # positions is the support positions , and load_position is the point load position (measured from far left)
                    mid_positions = [positions[i] for i in
                                     range(1, len(positions) - 1)]  # only positions of middle supports
                    L = beam_length

                    # determine the equations needed based on the edge conditions. all based on point load cases found in deflection tables

                    B = np.array(
                        [force * (L - i) ** 2 * p ** 2 / (6 * L ** 3) * (3 * i * L - 3 * p * i - p * (L - i)) if p < i
                         else force * (i) ** 2 * (L-p) ** 2 / (6 * L ** 3) * (3 * (L - i) * L - 3 * (L - i) * (L-p) - i * (L-p))
                         for p in mid_positions])
                    C = np.array(
                        [[(L - j) ** 2 * p ** 2 / (6 * L ** 3) * (3 * j * L - 3 * p * j - p * (L - j)) if p < j
                          else (j) ** 2 * (L-p) ** 2 / (6 * L ** 3) * (3 * (L - j) * L - 3 * (L - j) * (L-p) - j * (L-p))
                          for p in mid_positions] for j in mid_positions])
                    A = np.array([[C[k][m] for k in range(0, len(C))] for m in range(0, len(C))])
                    # Solve the system of equations
                    try:
                        solution = np.linalg.solve(A, B)
                        rounded_solution = np.round(solution, 6)
                        #solve for left moment
                        return rounded_solution
                    except np.linalg.LinAlgError:  # this will only occur if there are no middle reactions (2 support beam), hence an empty A matrix
                        return np.array([])



                # create a list of all the middle support reactions for every point load:
                L = beam_length
                start_time = time.time()  # End timing
                P_Reactions = np.array(
                    [create_solve_sys_equations(support_positions, i, j) for i, j in
                     zip(point_load_values, point_load_x)])
                print(f'Point Reactions={P_Reactions}')
                # additionally, the uniform loads will use the same method as the point loads to solve the Reactions, separating the uniform load
                # into smaller point loads spaced at a specific interval
                interval = .01  # this will match the shear/moment diagram interval
                u_load_conversion = np.array(
                    [i * interval for i in uniform_load_values])  # uniform load array with point load equivalent

                # Create ranges for each load using a list comprehension
                ranges = [np.arange(start + interval, end + interval, interval) for start, end in
                          zip(uniform_load_x_begin, uniform_load_x_end)]
                U_Reactions = []
                print(
                    f'the active iterated uniform load values are{u_load_conversion} and x-start values are {uniform_load_x_begin} and x_end values are{uniform_load_x_end}')
                for i, j in enumerate(u_load_conversion):
                    for k in ranges[i]:
                        U_Reactions.append(create_solve_sys_equations(support_positions, j, k))
                U_Reactions = np.array(U_Reactions)
                print(f'Uniform Reactions are {U_Reactions}')
                Total_Reactions = np.array(np.sum(P_Reactions, axis=0)) + np.array(np.sum(U_Reactions, axis=0))
                print(f'Total_Reactions={Total_Reactions}')
                print(Total_Reactions.ndim)

                # solve far left support by summing all the RA values calculated by the equation from tables
                if Total_Reactions.ndim != 0:  # ensures there are loads
                    RA_Reactions = np.array([-i*(L-j)**2*(3*j+(L-j))/(L**3)for i, j in zip(Total_Reactions, mid_positions)])
                    RB_Reactions = np.array([-i*(j)**2*((j)+3*(L-j))/(L**3) for i, j in zip(Total_Reactions, mid_positions)])
                    MA_Reactions= np.array([i*j*(L-j)**2/(L**2) for i, j in zip(Total_Reactions, mid_positions)])
                    MB_Reactions = np.array([i * j**2 * (L - j) / (L ** 2) for i, j in zip(Total_Reactions, mid_positions)])


                    RA_Point_Loads = np.array([i*(L-j)**2*(3*j+(L-j))/(L**3) for i, j in zip(point_load_values, point_load_x)])
                    RB_Point_Loads = np.array([i*(j)**2*((j)+3*(L-j))/(L**3) for i, j in zip(point_load_values, point_load_x)])
                    MA_Point_Loads = np.array([-i*j*(L-j)**2/(L**2) for i, j in zip(point_load_values, point_load_x)])
                    MB_Point_Loads = np.array([-i * j**2 * (L - j) / (L ** 2) for i, j in zip(point_load_values, point_load_x)])

                    RA_Uniform_Loads=[]
                    RB_Uniform_Loads=[]
                    MA_Uniform_Loads = []
                    MB_Uniform_Loads = []

                    for k, i in enumerate(u_load_conversion):
                        for j in ranges[k]:

                            RA_Uniform_Loads.append(i*(L-j)**2*(3*j+(L-j))/(L**3))
                            RB_Uniform_Loads.append(i*(j)**2*((j)+3*(L-j))/(L**3))
                            MA_Uniform_Loads.append(-i*j*(L-j)**2/(L**2))
                            MB_Uniform_Loads.append(-i * j**2 * (L - j) / (L ** 2))



                    RA_Uniform_Loads = np.array(RA_Uniform_Loads)
                    RB_Uniform_Loads = np.array(RB_Uniform_Loads)
                    MA_Uniform_Loads = np.array(MA_Uniform_Loads)
                    MB_Uniform_Loads = np.array(MB_Uniform_Loads)
                    print(RA_Uniform_Loads)
                    RA = np.sum(RA_Reactions) + np.sum(RA_Point_Loads) + np.sum(RA_Uniform_Loads)
                    RB = np.sum(RB_Reactions) + np.sum(RB_Point_Loads) + np.sum(RB_Uniform_Loads)
                    MA = np.sum(MA_Reactions) + np.sum(MA_Point_Loads) + np.sum(MA_Uniform_Loads)
                    MB = np.sum(MB_Reactions) + np.sum(MB_Point_Loads) + np.sum(MB_Uniform_Loads)

                    print(f'Total Moment about last support excluding Ay={RA}')

                    All_Reactions = []
                    All_Reactions.append(RA)
                    for i in Total_Reactions:
                        All_Reactions.append(i)
                    All_Reactions.append(RB)
                    All_Reactions = np.array(All_Reactions)
                    print(f'All Reactions={All_Reactions}')

                    # solve for deflection values using the known middle reactions, point loads, and uniform loads:
                    # Initialize arrays for R_D, P_D, and U_D with the size of x_diagram
                    # Discretize beam
                    # Initialize D as zero array with the size of x_diagram
                    D = np.zeros_like(x_diagram)

                    # Step 1: Compute R_D
                    for force, i in zip(Total_Reactions, mid_positions):
                        condition = x_diagram < i
                        R_D = np.where(
                            condition,
                            force * (L - i) ** 2 * x_diagram ** 2 / (6 * L ** 3) * (3 * i * L - 3 * x_diagram * i - x_diagram * (L - i)),
                            force * (i) ** 2 * (L-x_diagram) ** 2 / (6 * L ** 3) * (3 * (L - i) * L - 3 * (L - i) * (L-x_diagram) - i * (L-x_diagram))
                        )
                        D += R_D  # Add to total

                    # Step 2: Compute P_D
                    for force, i in zip(point_load_values, point_load_x):
                        condition = x_diagram < i
                        P_D = np.where(
                            condition,
                            -force * (L - i) ** 2 * x_diagram ** 2 / (6 * L ** 3) * (3 * i * L - 3 * x_diagram * i - x_diagram * (L - i)),
                            -force * (i) ** 2 * (L - x_diagram) ** 2 / (6 * L ** 3) * (3 * (L - i) * L - 3 * (L - i) * (L - x_diagram) - i * (L - x_diagram))
                        )
                        D += P_D  # Add to total

                    # Step 3: Compute U_D
                    for k, force in enumerate(u_load_conversion):
                        i_range = np.array(ranges[k])  # Convert range to array
                        for i in i_range:
                            condition = x_diagram < i
                            U_D = np.where(
                                condition,
                                -force * (L - i) ** 2 * x_diagram ** 2 / (6 * L ** 3) * (3 * i * L - 3 * x_diagram * i - x_diagram * (L - i)),
                                -force * (i) ** 2 * (L - x_diagram) ** 2 / (6 * L ** 3) * (3 * (L - i) * L - 3 * (L - i) * (L - x_diagram) - i * (L - x_diagram))
                            )
                            D += U_D  # Add to total


                else:
                    All_Reactions = np.array(
                        [0 for i in support_positions])  # this is just a placeholder for the reactions


            else: #placeholder for other edge conditions
                All_Reactions = np.array(
                    [0 for i in support_positions])  # this is just a placeholder for the reactions









        else:  # number of supports is 2
            if left == support_types[0] and right == support_types[0]:
                # required data for shear and moment diagram later
                interval = .01  # this will match the shear/moment diagram interval
                u_load_conversion = np.array(
                    [i * interval for i in uniform_load_values])  # uniform load array with point load equivalent
                ranges = [np.arange(start, end + interval, interval) for start, end in
                          zip(uniform_load_x_begin, uniform_load_x_end)]

                L = beam_length
                M_Point_Loads = np.array([-i * (L - j) for i, j in zip(point_load_values, point_load_x)])

                M_Uniform_Loads = np.array([-i * (k - j) * (L - (k - (k - j) / 2)) for i, j, k in
                                            zip(uniform_load_values, uniform_load_x_begin, uniform_load_x_end)])

                Total_M = np.sum(M_Point_Loads) + np.sum(M_Uniform_Loads)
                print(f'Total Moment about last support excluding Ay={Total_M}')

                A_y = -Total_M / L if Total_M != 0 else 0
                A_y = round(A_y, 6)
                print(A_y)

                # solve last reaction
                Last = sum(point_load_values) + sum([i * (k - j) for i, j, k in
                                                     zip(uniform_load_values, uniform_load_x_begin,
                                                         uniform_load_x_end)]) - A_y
                Last = round(Last, 6)
                All_Reactions = []
                All_Reactions.append(A_y)
                All_Reactions.append(Last)
                All_Reactions = np.array(All_Reactions)
                print(f'All Reactions={All_Reactions}')

                # solve for deflection values using the known middle reactions, point loads, and uniform loads:
                # Initialize arrays for R_D, P_D, and U_D with the size of x_diagram
                # Discretize beam
                # Initialize D as zero array with the size of x_diagram
                D = np.zeros_like(x_diagram)


                # Step 1: Compute P_D
                for force, i in zip(point_load_values, point_load_x):
                    condition = x_diagram < i
                    P_D = np.where(
                        condition,
                        -force * (L - i) * x_diagram / (6 * L) * (L ** 2 - (L - i) ** 2 - x_diagram ** 2),
                        -force * i * (L - x_diagram) / (6 * L) * (L ** 2 - i ** 2 - (L - x_diagram) ** 2),
                    )
                    D += P_D  # Add to total
                # Step 2: Compute U_D
                for k, force in enumerate(u_load_conversion):
                    i_range = np.array(ranges[k])  # Convert range to array
                    for i in i_range:
                        condition = x_diagram < i
                        U_D = np.where(
                            condition,
                            -force * (L - i) * x_diagram / (6 * L) * (L ** 2 - (L - i) ** 2 - x_diagram ** 2),
                            -force * i * (L - x_diagram) / (6 * L) * (L ** 2 - i ** 2 - (L - x_diagram) ** 2),
                        )
                        D += U_D  # Add to total

            elif left == support_types[0] and right == support_types[1]:
                interval = .01  # this will match the shear/moment diagram interval
                u_load_conversion = np.array(
                    [i * interval for i in uniform_load_values])  # uniform load array with point load equivalent
                ranges = [np.arange(start, end + interval, interval) for start, end in
                          zip(uniform_load_x_begin, uniform_load_x_end)]

                L = beam_length

                RA_Point_Loads = np.array(
                    [i * (L - j) ** 2 * (j + 2 * L) / (2 * L ** 3) for i, j in zip(point_load_values, point_load_x)])
                RB_Point_Loads = np.array([i * (j) * (3 * L ** 2 - j ** 2) / (2 * L ** 3) for i, j in
                                           zip(point_load_values, point_load_x)])
                MB_Point_Loads = np.array([-i * (j * (L - j)) * (L + j) / (2 * L ** 2) for i, j in
                                           zip(point_load_values, point_load_x)])

                RA_Uniform_Loads = []
                RB_Uniform_Loads = []
                MB_Uniform_Loads = []
                for k, i in enumerate(u_load_conversion):
                    for j in ranges[k]:
                        RA_Uniform_Loads.append(i * (L - j) ** 2 * (j + 2 * L) / (2 * L ** 3))
                        RB_Uniform_Loads.append(i * (j) * (3 * L ** 2 - j ** 2) / (2 * L ** 3))
                        MB_Uniform_Loads.append(-i * (j * (L - j)) * (L + j) / (2 * L ** 2))

                RA_Uniform_Loads = np.array(RA_Uniform_Loads)
                RB_Uniform_Loads = np.array(RB_Uniform_Loads)
                MB_Uniform_Loads = np.array(MB_Uniform_Loads)

                RA =  np.sum(RA_Point_Loads) + np.sum(RA_Uniform_Loads)
                RB =  np.sum(RB_Point_Loads) + np.sum(RB_Uniform_Loads)
                MB =  np.sum(MB_Point_Loads) + np.sum(MB_Uniform_Loads)

                print(f'Total Moment about last support excluding Ay={RA}')

                All_Reactions = [RA,RB]
                All_Reactions = np.array(All_Reactions)
                print(f'All Reactions={All_Reactions}')

                D = np.zeros_like(x_diagram)

                # Step 1: Compute P_D
                for force, i in zip(point_load_values, point_load_x):
                    condition = x_diagram < i
                    P_D = np.where(
                        condition,
                        -force * (L - i) ** 2 * x_diagram / (12 * L ** 3) * (3 * i * L ** 2 - 2 * L * x_diagram ** 2 - i * x_diagram ** 2),
                        -force * i / (12 * L ** 3) * ((L - x_diagram) ** 2) * (3 * L ** 2 * x_diagram - x_diagram * i ** 2 - 2 * L * i ** 2),
                    )
                    D += P_D  # Add to total

                # Step 2: Compute U_D
                for k, force in enumerate(u_load_conversion):
                    i_range = np.array(ranges[k])  # Convert range to array
                    for i in i_range:
                        condition = x_diagram < i
                        U_D = np.where(
                            condition,
                            -force * (L - i) ** 2 * x_diagram / (12 * L ** 3) * (3 * i * L ** 2 - 2 * L * x_diagram ** 2 - i * x_diagram ** 2),
                            -force * i / (12 * L ** 3) * ((L - x_diagram) ** 2) * (3 * L ** 2 * x_diagram - x_diagram * i ** 2 - 2 * L * i ** 2),
                        )
                        D += U_D  # Add to total


            elif left == support_types[1] and right == support_types[0]: #moment on left, pinned on right
                interval = .01  # this will match the shear/moment diagram interval
                u_load_conversion = np.array(
                    [i * interval for i in uniform_load_values])  # uniform load array with point load equivalent
                ranges = [np.arange(start, end + interval, interval) for start, end in
                          zip(uniform_load_x_begin, uniform_load_x_end)]

                L = beam_length


                RA_Point_Loads = np.array([i * (L - j) * (3 * L ** 2 - (L - j) ** 2) / (2 * L ** 3) for i, j in
                                           zip(point_load_values, point_load_x)])
                RB_Point_Loads = np.array([i * (j) ** 2 * ((L - j) + 2 * L) / (2 * L ** 3) for i, j in
                                           zip(point_load_values, point_load_x)])
                MA_Point_Loads = np.array([-i * (j * (L - j)) * (L + (L - j)) / (2 * L ** 2) for i, j in
                                           zip(point_load_values, point_load_x)])
                RA_Uniform_Loads = []
                RB_Uniform_Loads = []
                MA_Uniform_Loads = []
                for k, i in enumerate(u_load_conversion):
                    for j in ranges[k]:
                        RA_Uniform_Loads.append(i * (L - j) * (3 * L ** 2 - (L - j) ** 2) / (2 * L ** 3))
                        RB_Uniform_Loads.append(i * (j) ** 2 * ((L - j) + 2 * L) / (2 * L ** 3))
                        MA_Uniform_Loads.append(-i * (j * (L - j)) * (L + (L - j)) / (2 * L ** 2))

                RA_Uniform_Loads = np.array(RA_Uniform_Loads)
                RB_Uniform_Loads = np.array(RB_Uniform_Loads)
                MA_Uniform_Loads = np.array(MA_Uniform_Loads)
                print(RA_Uniform_Loads)
                RA = np.sum(RA_Point_Loads) + np.sum(RA_Uniform_Loads)
                RB = np.sum(RB_Point_Loads) + np.sum(RB_Uniform_Loads)
                MA = np.sum(MA_Point_Loads) + np.sum(MA_Uniform_Loads)

                print(f'Total Moment about last support excluding Ay={RA}')

                All_Reactions = [RA,RB]
                All_Reactions = np.array(All_Reactions)
                print(f'All Reactions={All_Reactions}')

                D = np.zeros_like(x_diagram)

                # Step 2: Compute P_D
                for force, i in zip(point_load_values, point_load_x):
                    condition = (L - x_diagram) < (L - i)
                    P_D = np.where(condition,
                        -force * (i) ** 2 * (L - x_diagram) / (12 * L ** 3) * (3 * (L - i) * L ** 2 - 2 * L * (L - x_diagram) ** 2 - (L - i) * (L - x_diagram) ** 2),
                        -force * (L - i) / (12 * L ** 3) * (x_diagram ** 2) * (3 * L ** 2 * (L - x_diagram) - (L - x_diagram) * (L - i) ** 2 - 2 * L * (L - i) ** 2),
                    )
                    D += P_D  # Add to total

                # Step 3: Compute U_D
                for k, force in enumerate(u_load_conversion):
                    i_range = np.array(ranges[k])  # Convert range to array
                    for i in i_range:
                        condition = (L - x_diagram) < (L - i)
                        U_D = np.where(condition,
                            -force * (i) ** 2 * (L - x_diagram) / (12 * L ** 3) * (3 * (L - i) * L ** 2 - 2 * L * (L - x_diagram) ** 2 - (L - i) * (L - x_diagram) ** 2),
                            -force * (L - i) / (12 * L ** 3) * (x_diagram ** 2) * (3 * L ** 2 * (L - x_diagram) - (L - x_diagram) * (L - i) ** 2 - 2 * L * (L - i) ** 2),
                        )
                        D += U_D  # Add to total

            elif left == support_types[1] and right == support_types[1]: #moment on left, moment on right
                interval = .01  # this will match the shear/moment diagram interval
                u_load_conversion = np.array(
                    [i * interval for i in uniform_load_values])  # uniform load array with point load equivalent
                ranges = [np.arange(start, end + interval, interval) for start, end in
                          zip(uniform_load_x_begin, uniform_load_x_end)]

                L = beam_length


                RA_Point_Loads = np.array(
                    [i * (L - j) ** 2 * (3 * j + (L - j)) / (L ** 3) for i, j in zip(point_load_values, point_load_x)])
                RB_Point_Loads = np.array(
                    [i * (j) ** 2 * ((j) + 3 * (L - j)) / (L ** 3) for i, j in zip(point_load_values, point_load_x)])
                MA_Point_Loads = np.array(
                    [-i * j * (L - j) ** 2 / (L ** 2) for i, j in zip(point_load_values, point_load_x)])
                MB_Point_Loads = np.array(
                    [-i * j ** 2 * (L - j) / (L ** 2) for i, j in zip(point_load_values, point_load_x)])

                RA_Uniform_Loads = []
                RB_Uniform_Loads = []
                MA_Uniform_Loads = []
                MB_Uniform_Loads = []

                for k, i in enumerate(u_load_conversion):
                    for j in ranges[k]:
                        RA_Uniform_Loads.append(i * (L - j) ** 2 * (3 * j + (L - j)) / (L ** 3))
                        RB_Uniform_Loads.append(i * (j) ** 2 * ((j) + 3 * (L - j)) / (L ** 3))
                        MA_Uniform_Loads.append(-i * j * (L - j) ** 2 / (L ** 2))
                        MB_Uniform_Loads.append(-i * j ** 2 * (L - j) / (L ** 2))

                RA_Uniform_Loads = np.array(RA_Uniform_Loads)
                RB_Uniform_Loads = np.array(RB_Uniform_Loads)
                MA_Uniform_Loads = np.array(MA_Uniform_Loads)
                MB_Uniform_Loads = np.array(MB_Uniform_Loads)
                print(RA_Uniform_Loads)
                RA = np.sum(RA_Point_Loads) + np.sum(RA_Uniform_Loads)
                RB = np.sum(RB_Point_Loads) + np.sum(RB_Uniform_Loads)
                MA = np.sum(MA_Point_Loads) + np.sum(MA_Uniform_Loads)
                MB = np.sum(MB_Point_Loads) + np.sum(MB_Uniform_Loads)

                print(f'Total Moment about last support excluding Ay={RA}')

                All_Reactions = [RA,RB]
                All_Reactions = np.array(All_Reactions)
                print(f'All Reactions={All_Reactions}')

                D = np.zeros_like(x_diagram)

                # Step 1: Compute P_D
                for force, i in zip(point_load_values, point_load_x):
                    condition = x_diagram < i
                    P_D = np.where(
                        condition,
                        -force * (L - i) ** 2 * x_diagram ** 2 / (6 * L ** 3) * (
                                    3 * i * L - 3 * x_diagram * i - x_diagram * (L - i)),
                        -force * (i) ** 2 * (L - x_diagram) ** 2 / (6 * L ** 3) * (
                                    3 * (L - i) * L - 3 * (L - i) * (L - x_diagram) - i * (L - x_diagram))
                    )
                    D += P_D  # Add to total

                # Step 2: Compute U_D
                for k, force in enumerate(u_load_conversion):
                    i_range = np.array(ranges[k])  # Convert range to array
                    for i in i_range:
                        condition = x_diagram < i
                        U_D = np.where(
                            condition,
                            -force * (L - i) ** 2 * x_diagram ** 2 / (6 * L ** 3) * (
                                        3 * i * L - 3 * x_diagram * i - x_diagram * (L - i)),
                            -force * (i) ** 2 * (L - x_diagram) ** 2 / (6 * L ** 3) * (
                                        3 * (L - i) * L - 3 * (L - i) * (L - x_diagram) - i * (L - x_diagram))
                        )
                        D += U_D  # Add to total

        end_time_R = time.time()  # End timing
        print(f" computing reactions creation time: {end_time_R - start_time_R:.4f} seconds")
        # once the reactions are determined, solve y array as a result of the reactions and loads

        start_time_F = time.time()
        # Reactions
        R = All_Reactions  # Reaction forces.
        Rx = support_positions  # Reaction positions

        # point loads
        P = point_load_values  # point loads
        Px = point_load_x  # point load positions

        u = uniform_load_values
        uxb = uniform_load_x_begin
        uxe = uniform_load_x_end

        # Discretize beam
        x = np.arange(0, beam_length + .01, .01)
        shear_force = np.zeros_like(x)
        dx = x[1] - x[0]  # Step size

        # Apply reactions
        for rxn, pos in zip(R, Rx):
            shear_force[x >= pos] += rxn

        # Apply point loads
        for load, pos in zip(P, Px):
            shear_force[x >= pos] -= load

        # Apply UDLs
        # Apply UDLs
        for intensity, start, end in zip(u, uxb, uxe):
            shear_force[(x >= start) & (x <= end)] -= intensity * (x[(x >= start) & (x <= end)] - start)
            shear_force[x > end] -= intensity * (end - start)


        # Compute moment diagram (cumulative integration of shear force + relevant end moments)
        print(f'MA={MA}')
        print(f'MB={MB}')
        moment = np.cumsum(shear_force) * dx +MA
        #moment[-1] -=MB
        deflection= D #calculated earlier
        end_time_F = time.time()  # End timing
        print(f" shear and moment data creation time: {end_time_F - start_time_F:.4f} seconds")
        # Compute shear diagram
        x_diagram, V, M, D = x, shear_force, moment, deflection
        completion = True


    # with the solved Reactions, add them to the beam diagram with an arrow
    for pos, R in zip(support_positions, All_Reactions):
        # Add a vertical arrow at the x position under the support labels
        if R >= 0:
            annotations.append(dict(
                x=pos,
                y=-.75,
                xref="x",
                yref="y",
                text=f"<b>{round(abs(R), 2)} kip<b>",
                showarrow=True,
                arrowhead=2,
                ax=0,
                ay=80,
                arrowcolor='#8B0000',
                arrowwidth=2,
                font=dict(size=12, color='black')
            ))
        else:  # negative reaction
            annotations.append(dict(
                x=pos,
                y=-1.95,
                xref="x",
                yref="y",
                showarrow=True,
                arrowhead=2,
                ax=0,
                ay=-80,
                arrowcolor='#8B0000',
                arrowwidth=2,
                font=dict(size=12, color='black')
            ))
            annotations.append(dict(
                x=pos, y=-2.1,  # Position text slightly below the arrow tail
                xref='x', yref='y',
                text=f"<b>{round(abs(R), 2)} kip<b>",
                showarrow=False,
                font=dict(size=12, color='black')
            ))
    if right == support_types[1]:  # if there is a fixed right support
        L = beam_length
        if MB>=0:
            annotations.append(dict(
                x=L * 1.05,
                y=+support_height,
                ax=L * 1.07*10/L,  # Control point x (for direction of the arrowhead)
                ay=L * 1.06*10/L,  # Control point y
                xref="x",
                yref="y",
                showarrow=True,
                arrowhead=2,
                arrowcolor='#8B0000',
                arrowwidth=2,
                font=dict(size=12, color='black')
            ))
        else:
            annotations.append(dict(
                x=L * 1.05,
                y=-support_height,
                ax=L * 1.07 * 10 / L,  # Control point x (for direction of the arrowhead)
                ay=-L * 1.06 * 10 / L,  # Control point y
                xref="x",
                yref="y",
                showarrow=True,
                arrowhead=2,
                arrowcolor='#8B0000',
                arrowwidth=2,
                font=dict(size=12, color='black')
            ))
        annotations.append(dict(
            x=L * 1.04,
            y=0,
            xref='x', yref='y',
            text=f'<b>{abs(round(MB, 1))} k-ft<b>',
            showarrow=False,
            font=dict(size=12, color='black'),
        ))
    else:
        pass

    if left == support_types[1]:  # if there is a fixed right support
        L = beam_length
        if MA>=0:
            annotations.append(dict(
                x=-L * .05,
                y=+support_height,
                ax=-L * 1.07 * 10 / L,  # Control point x (for direction of the arrowhead)
                ay=L * 1.06 * 10 / L,  # Control point y
                xref="x",
                yref="y",
                showarrow=True,
                arrowhead=2,
                arrowcolor='#8B0000',
                arrowwidth=2,
                font=dict(size=12, color='black')
            ))
        else:
            annotations.append(dict(
                x=-L * .05,
                y=-support_height,
                ax=-L * 1.07 * 10 / L,  # Control point x (for direction of the arrowhead)
                ay=-L * 1.06 * 10 / L,  # Control point y
                xref="x",
                yref="y",
                showarrow=True,
                arrowhead=2,
                arrowcolor='#8B0000',
                arrowwidth=2,
                font=dict(size=12, color='black')
            ))

        annotations.append(dict(
            x=L-(L * 1.04),
            y=0,
            xref='x', yref='y',
            text=f'<b>{abs(round(MA, 1))} k-ft<b>',
            showarrow=False,
            font=dict(size=12, color='black'),
        ))
    else:
        pass
    # Combine the beam and support traces
    beam_fig = go.Figure(data=[beam_trace] + support_traces + label_traces)

    #add curved tail for arrow. this step is done after beam figure is defined so that add_shape can be used.
    if right == support_types[1]: #if there is a fixed right support
        L=beam_length
        #add curved line to left side
        beam_fig.add_shape(
                    type="path",
                    path=f'M {(L*1.05)},{(-support_height)} Q {(L*1.1)},0 {(L*1.05)},{(+support_height)}',
                    line_color='#8B0000',
                ),
    else:
        pass
    if left == support_types[1]: #if there is a fixed right support
        L=beam_length
        #add curved line to left side
        beam_fig.add_shape(
                    type="path",
                    path=f'M {(L-(L*1.05))},{(-support_height)} Q {(L-(L*1.1))},0 {(L-(L*1.05))},{(+support_height)}',
                    line_color='#8B0000',
                ),
    else:
        pass

    beam_fig.update_layout(
        xaxis=dict(title='Length (ft)', range=[beam_length-beam_length *1.1, beam_length *1.1], showticklabels=False,
                   zeroline=False, showgrid=False),
        yaxis=dict(title='', range=[-support_height - 1.75, 2], showticklabels=False,
                   zeroline=False, showgrid=False),
        showlegend=False,
        height=300,
        margin=dict(l=0, r=0, t=0, b=0),
        annotations=annotations,
        plot_bgcolor='#E8EEF7',  # Light blue background for the plot area
        paper_bgcolor='#E8EEF7'  # Gray background for the outer area
    )

    # =====================
    # Update Shear Graph
    # =====================

    equation_trace = go.Scatter(
        x=x_diagram,
        y=V,
        mode='lines',
        name=f'{force}',
        line=dict(color='#000080', width=3),
        hovertemplate='x: %{x:.2f} ft <br>Shear: %{y:.2f} kip<extra></extra>'
    )
    zero_line = go.Scatter(
        x=[0, beam_length],
        y=[0, 0],
        mode='lines',
        line=dict(color='red', width=2, dash='dash'),
        name='y = 0 (horizontal line)')

    # Create the Shear figure
    equation_fig = go.Figure(data=[equation_trace] + [zero_line])
    if not completion:
        equation_fig.add_annotation(x=beam_length / 2,  # X-coordinate
                                    y=.5,  # Y-coordinate
                                    text="Shear Diagram not available yet. try again soon!",  # The text to display
                                    font=dict(size=36, color='black'),

                                    )
    if not stability:
        equation_fig.add_annotation(x=beam_length / 2,  # X-coordinate
                                    y=.5,  # Y-coordinate
                                    text="WARNING: STRUCTURE UNSTABLE!",  # The text to display
                                    font=dict(size=24, color='red'),

                                    )
    else:
        pass

    equation_fig.update_layout(
        xaxis=dict(title='Length (ft)', range=[0, beam_length]),
        yaxis=dict(title='Shear Value', range=[min(V) * 1.1, max(V) * 1.1]),
        showlegend=False,
        hovermode='closest',
        margin=dict(l=0, r=0, t=0, b=0),
        plot_bgcolor='#E8EEF7',  # Light blue background for the plot area
        paper_bgcolor='#E8EEF7'  # Gray background for the outer area
    )

    # =====================
    # Update Moment Graph
    # =====================
    equation_trace_M = go.Scatter(
        x=x_diagram,
        y=M,
        mode='lines',
        name=f'{force}',
        line=dict(color='#000080', width=3),
        hovertemplate='x: %{x:.2f} ft <br>Moment: %{y:.2f} kip-ft<extra></extra>'
    )
    zero_line_M = go.Scatter(
        x=[0, beam_length],
        y=[0, 0],
        mode='lines',
        line=dict(color='red', width=2, dash='dash'),
        name='y = 0 (horizontal line)')

    # Create the Moment figure
    equation_fig_M = go.Figure(data=[equation_trace_M] + [zero_line_M])
    if not completion:
        equation_fig_M.add_annotation(x=beam_length / 2,  # X-coordinate
                                      y=.5,  # Y-coordinate
                                      text="Moment diagram not available yet. try again soon!",  # The text to display
                                      font=dict(size=36, color='black'),

                                      )
    if not stability:
        equation_fig_M.add_annotation(x=beam_length / 2,  # X-coordinate
                                      y=.5,  # Y-coordinate
                                      text="WARNING: STRUCTURE UNSTABLE!",  # The text to display
                                      font=dict(size=24, color='red'),

                                      )
    else:
        pass

    equation_fig_M.update_layout(
        xaxis=dict(title='Length (ft)', range=[0, beam_length]),
        yaxis=dict(title='Moment Value', range=[min(M) * 1.1, max(M) * 1.1]),
        showlegend=False,
        hovermode='closest',
        margin=dict(l=0, r=0, t=0, b=0),
        plot_bgcolor='#E8EEF7',  # Light blue background for the plot area
        paper_bgcolor='#E8EEF7'  # Gray background for the outer area
    )

    # =====================
    # Update Deflection Graph
    # =====================


    equation_trace_D = go.Scatter(
        x=x_diagram,
        y=D,
        mode='lines',
        name='deflection (ft)',
        line=dict(color='#000080', width=3),
        hovertemplate='x: %{x:.2f} ft <br>deflection (ft): %{y:.2f} /EI<extra></extra>'
    )
    zero_line_D = go.Scatter(
        x=[0, beam_length],
        y=[0, 0],
        mode='lines',
        line=dict(color='red', width=2, dash='dash'),
        name='y = 0 (horizontal line)')

    # Create the Moment figure
    equation_fig_D = go.Figure(data=[equation_trace_D] + [zero_line_D])
    if not completion:
        equation_fig_D.add_annotation(x=beam_length / 2,  # X-coordinate
                                      y=.5,  # Y-coordinate
                                      text="Deflection diagram not available yet. try again soon!",  # The text to display
                                      font=dict(size=36, color='black'),

                                      )
    if not stability:
        equation_fig_D.add_annotation(x=beam_length / 2,  # X-coordinate
                                      y=.5,  # Y-coordinate
                                      text="WARNING: STRUCTURE UNSTABLE!",  # The text to display
                                      font=dict(size=24, color='red'),

                                      )
    else:
        pass

    equation_fig_D.update_layout(
        xaxis=dict(title='Length (ft)', range=[0, beam_length]),
        yaxis=dict(title='Deflection (ft)/EI', range=[-max(abs(min(D)),max(D)) * 5, max(abs(min(D)),max(D)) * 5]),
        showlegend=False,
        hovermode='closest',
        margin=dict(l=0, r=0, t=0, b=0),
        plot_bgcolor='#E8EEF7',  # Light blue background for the plot area
        paper_bgcolor='#E8EEF7'  # Gray background for the outer area
    )



    # update the design summary table
    # summary_table["Critical"][summary_table[" "].index('Shear')]=max(V)
    # summary_table["Critical"][summary_table[" "].index('Moment')]=max(M)

    # find the absolute maximums
    max_V = max(abs(v) for v in V)
    max_M = max(abs(m) for m in M)
    max_D= max(abs(d) for d in D)

    summary_table[0]["Critical"] = round(max_V, 1)
    summary_table[1]["Critical"] = round(max_M, 1)
    summary_table[2]["Critical"] = round(max_D, 1)


    return beam_fig, equation_fig, equation_fig_M, equation_fig_D , summary_table


# Run the app
if __name__ == '__main__':
    app.run_server(debug=True)
